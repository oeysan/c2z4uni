#' @title Create HTML and Metadata Files from Cristin Data for Web Display
#' @description This function processes monthly Cristin data to generate HTML content
#' and metadata files for web display. It uses \code{htmltools} to construct interactive HTML
#' elements (e.g., buttons, articles) for each publication, and optionally writes markdown files
#' with frontmatter for further processing.
#' @param monthlies Data containing monthly information from Cristin.
#' @param sdg.data Data containing information about Sustainable Development Goals (SDGs). Default is \code{NULL}.
#' @param sdg.path Path to SDG images. Default is \code{NULL}.
#' @param archive.url Relative URL to the archive. Default is \code{NULL}.
#' @param local.storage Path to the local storage directory. Default is \code{NULL}.
#' @param user.cards Logical, indicating whether to update user information from INN. Default is \code{TRUE}.
#' @param md.path Path to output markdown files. Default is an empty string (current directory).
#' @param md.save Logical, indicating whether to save the markdown files to disk. Default is \code{FALSE}.
#' @param use.multisession Logical. If \code{TRUE}, parallel processing using multisession is employed;
#' otherwise, processing is sequential. Default is \code{FALSE}.
#' @param min.multisession Minimum number of results for using multisession. Default is \code{25}.
#' @param n.workers Optional integer for the number of workers to be used in multisession mode.
#' If \code{NULL}, it defaults to the number of available cores minus one (with a minimum of one).
#' @param handler The progress handler to be used by the \code{progressr} package. Default is \code{"cli"}.
#' @param restore.defaults Logical. If \code{TRUE}, the current \code{future} plan is saved and restored upon exit.
#' Default is \code{FALSE}.
#' @param full.update Logical, indicating whether to perform a full update of user information from INN.
#' Default is \code{FALSE}.
#' @param lang Language for localization ("nb", "nn", "no", or "en"). Defaults to \code{"nn"}.
#' If \code{lang} is set to \code{"no"}, it is internally converted to \code{"nn"}. Any language not in
#' \code{c("nb", "nn", "no")} is set to \code{"en"}.
#' @param silent Logical, indicating whether to suppress log messages. Default is \code{FALSE}.
#' @param log List to store log messages. Default is an empty list.
#' @return A list containing two elements:
#' \item{results}{A tibble with metadata and HTML content (as generated by \code{htmltools}) for each publication.}
#' \item{log}{A log of processing messages.}
#' @details This function is typically used with \code{CristinMonthly} to convert monthly publication data
#' into HTML components and markdown files with frontmatter metadata. The function leverages \code{htmltools}
#' to programmatically build HTML elements such as articles and buttons for links to additional publication information.
#' @examples
#' \donttest{
#'   # Create monthlies for unit 209.5.10.0
#'   example <- CristinMonthly(
#'     c2z::Zotero(
#'       id = "4827927",
#'       api = "Io1bwAiOjB1jPgUNegjJhJxF",
#'       user = FALSE
#'     ),
#'     unit.id = "209.5.10.0",
#'     start.date = "2023-07",
#'     post = TRUE,
#'     silent = TRUE,
#'     use.citeproc = FALSE
#'   )
#'
#'   # Generate HTML and markdown files
#'   example.web <- CristinWeb(
#'     example$monthlies,
#'     user.cards = FALSE
#'   )
#'
#'   # Print the three first publication titles (if any)
#'   if (!is.null(example$monthlies)) {
#'     example$monthlies |>
#'       dplyr::select(title) |>
#'       print(n = 3, width = 80)
#'   }
#' }
#' @rdname CristinWeb
#' @export
CristinWeb <- \(monthlies,
                sdg.data = NULL,
                sdg.path = NULL,
                archive.url = NULL,
                local.storage = NULL,
                user.cards = TRUE,
                md.path = "",
                md.save = FALSE,
                use.multisession = FALSE,
                min.multisession = 25,
                n.workers = NULL,
                handler = "cli",
                restore.defaults = FALSE,
                full.update = FALSE,
                lang = "nn",
                silent = FALSE,
                log = list()) {

  # Return NULL if no monthlies
  if (!any(nrow(monthlies))) {
    return(NULL)
  }

  # Visible bindings
  cristin.id <- inn.cards <- research.type <- research.design <- synopsis <-
    keywords <- abstract <- contributors <- sdg <- synopsis.button <-
    keywords.button <- abstract.button <- contributors.button <-  sdg.button <-
    path <- frontmatter <- NULL

  # Languages: if lang is "no" set to "nn"; if not Norwegian, set to "en"
  if (lang %in% c("no")) lang <- "nn"
  if (!lang %in% c("nb", "nn", "no")) lang <- "en"

  # Update user info (cards) if requested
  if (user.cards) {
    inn.cards <- GetCards(local.storage, full.update, lang, silent)
  }

  # Inner function that creates a params list for a single publication/item.
  CreateParams <- \(item) {

    CreateButton <- \(name, url, lang) {

      if (any(is.na(GoFish(url)))) return (NULL)
      dict.name <- Dict(name, lang)
      if (is.null(dict.name)) dict.name <- name

      button <- htmltools::a(
        dict.name,
        href = url,
        alt = name,
        class = "csl-bib-button"
      )

      return (button)
    }

    CreateArticle <- \(name, data, key, lang) {
      if (any(is.na(GoFish(data)))) return (NULL)
      dict.name <- Dict(name, lang)
      if (is.null(dict.name)) dict.name <- name
      article <- htmltools::tags$article(
        htmltools::h1(dict.name),
        htmltools::HTML(data),
        id = paste0(name, "-article-", key),
        class = paste0(name, "-article")
      )
    }

    CreateArchive <- \(collection, archive.url, key, lang, header.text = NULL) {
      # Use a default header if none is provided.
      if (is.null(header.text)) {
        header.text <- Dict("archive", lang)
      }

      # Create the header tag.
      header.tag <- htmltools::h1(header.text)

      # Helper function to create individual list items with hrefs
      ListItems <- \(keys, names, base.url) {
        htmltools::tags$ul(mapply(
          \(key, name) htmltools::tags$li(
            htmltools::a(href = paste0(base.url, key), name)
          ),
          keys,
          names,
          SIMPLIFY = FALSE
        ))
      }

      # Generate multiple unordered lists
      ul.list <- htmltools::tagList(mapply(
        ListItems,
        collection$collection.keys,
        collection$collection.names,
        MoreArgs = list(base.url = archive.url),
        SIMPLIFY = FALSE
      ))

      # Build the complete article tag.
      archive.list <- htmltools::tags$article(
        header.tag,
        ul.list,
        # Optionally add an id based on item.key if provided.
        id = if (!is.null(key)) paste0("taxonomy-article-", key) else NULL,
        class = "taxonomy-article"
      )

      return(archive.list)
    }

    key <- item$key
    version  <- item$version
    cristin.button <- CreateButton("Cristin", item$cristin.url, lang)
    zotero.button <- CreateButton("Zotero", item$zotero.url, lang)
    unpaywall.button <- CreateButton("Unpaywall", item$unpaywall, lang)
    ezproxy.button<- CreateButton("EZproxy", item$unpaywall, lang)

    # Define Archive
    if (any(!is.na(GoFish(item$collection.paths)))) {
      archive.url <- paste0("/", lang, "/archive/?key=")
      archive <- CreateArchive(item$collection.paths[[1]], archive.url, key, lang)
      archive.button <- CreateButton(
        "archive",
        paste0("#", paste0("taxonomy-article-", key)),
        lang
      )
    }

    if (any(!is.na(GoFish(item$synopsis)))) {
      synopsis.button <- CreateButton(
        "about_pub",
        paste0("#", paste0("about-article-", key)),
        lang
      )
      synopsis <- CreateArticle("about_pub", item$synopsis, key, lang)
    }

    if (any(!is.na(GoFish(item$keywords)))) {
      keywords.button <- CreateButton(
        "keywords",
        paste0("#", paste0("keywords-article-", key)),
        lang
      )
      keywords <- CreateArticle(
        "keywords",
        paste(item$keywords[[1]], collapse = ", "),
        key,
        lang
      )
    }

    if (any(!is.na(GoFish(item$abstract)))) {
      abstract.button <- CreateButton(
        "abstract",
        paste0("#", paste0("abstract-article-", key)),
        lang
      )
      abstract <- CreateArticle(
        "abstract",
        CleanAbstract(item$abstract),
        key,
        lang
      )
    }

    if (any(!is.na(GoFish(item$cristin.ids[[1]]))) & any(nrow(inn.cards))) {
      ids <- item$cristin.ids[[1]]
      inn.card <- inn.cards |>
        dplyr::filter(cristin.id %in% ids) |>
        dplyr::arrange(match(cristin.id, ids))

      if (any(nrow(inn.card))) {

        contributors.button <- CreateButton(
          "contributors",
          paste0("#", paste0("contributors-article-", key)),
          lang
        )
        contributors <- CreateArticle("contributors", inn.card$card, key, lang)
      }
    }

    if (any(!is.na(GoFish(item$sdg[[1]]))) & any(length(sdg.data$sum))) {

      sdg.data <- SdgInfo(
        sdg.data$sum,
        as.numeric(item$sdg[[1]]),
        lang = lang,
        sdg.path,
        archive.url
      )

      sdg.button <- CreateButton(
        "sdg",
        paste0("#", paste0("sdg-article-", key)),
        lang
      )
      sdg <- htmltools::tagAppendChild(
        htmltools::tags$article(
          htmltools::h1(Dict("sdg", lang)),
          id = paste0("sdg-article-", key),
          class = "sdg-article"
        ),
        htmltools::div(
          sdg.data |>
            do.call(what = htmltools::HTML),
          class = "sdg-container"
        )
      )
    }

    if (any(!is.na(GoFish(item$bib)))) {
      md.data <- htmltools::tagList(
        htmltools::h1(Dict("publication", lang)),
        htmltools::tagAppendChildren(
          # Reference
          htmltools::tags$article(
            id = paste0("csl-bib-container-", key),
            class = "csl-bib-container",
            htmltools::HTML(item$bib)
          ),
          # Buttons
          htmltools::div(
            archive.button,
            cristin.button,
            zotero.button,
            keywords.button,
            synopsis.button,
            contributors.button,
            sdg.button,
            unpaywall.button,
            ezproxy.button,
            class = "csl-bib-buttons"
          ),
          htmltools::div(
            id = paste0("csl-bib-meta-container-", key)
          )
        ),
        htmltools::div(
          # Synopsis
          synopsis,
          # Keywords,
          keywords,
          # Abstract
          abstract,
          # Contributors
          contributors,
          # SDG
          sdg,
          # Taxonomy
          archive,
          id = paste0("csl-bib-meta-", key),
          class = "csl-bib-meta"
        )
      )

      frontmatter <- sprintf('title: "%s"\ntype: pub\nencoding: UTF-8', item$title)
      path <- file.path(md.path, paste0(key, ".md"))
      if (md.save) {
        writeLines(
          c("---", frontmatter ,"---", as.character(md.data)),
          path
        )
      }
    }

    return.data <- tibble::tibble(
      key = key,
      version = version,
      frontmatter = frontmatter,
      md.data = list(md.data),
      path = path,
      year = item$year,
      month = item$month,
      year.month = item$year.month,
      lang = lang
    )

  }

  start.message <- sprintf(
    "Converting %s to Rmd params",
    Numerus(nrow(monthlies), "item")
  )

  monthlies.data <- c2z::ProcessData(
    data = monthlies,
    func = CreateParams,
    by.rows = TRUE,
    min.multisession = min.multisession,
    n.workers = n.workers,
    limit = 100,
    use.multisession = use.multisession,
    start.message = start.message,
    handler = handler,
    silent = silent
  )

  results <- monthlies.data$results
  log <- c(log, monthlies.data$log)

  return(list(results = results, log = log))
}
